<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html
><head
><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
><title
>dyn: dynamic binding that works with exceptions, continuations, and threads</title
><style type="text/css"
>


body {
  font-family: verdana;
  margin-left: 2em;
}

p, ol, ul {
  width: 40em;
}

li {
  margin-bottom: 0.5em;
}

pre, code {
  font-family: courier;
}

td {
  vertical-align: top;
  padding: 0 1em 0.5em 0;
}

table.code {
  border-collapse: collapse;
}

table.code td {
  padding: 5px 1em;
  font-family: courier, monospace;
  border: 1px solid #ddd;
}

table.code td.arrow {
  border: none;
  padding: 0 1em;
  font-family: verdana;
}

table.code td.spacer {
  border: none;
  padding: 0;
}

table.foo {
  border-collapse: collapse;
}

table.foo th {
  border: none 0px;
}

table.foo td {
  vertical-align: baseline;
  padding: 1em;
  border: 1px solid #ccc;
}


</style
></head
><body
><a href="/"
>Cat’s hacks</a
>:<h2
>dyn: dynamic binding that works with exceptions, continuations, and threads</h2
><p
>MzScheme has a feature called <a href="http://download.plt-scheme.org/doc/372/html/mzscheme/mzscheme-Z-H-7.html#node_sec_7.9"
>parameters</a
> which implements a form of dynamic binding.  What’s cool about MzScheme’s implementation is that the dynamic binding actually works correctly in the presence of exceptions, continuations, and threads, which flummox more naive implementations of dynamic binding.</p
><p
>Arc uses these MzScheme parameters for stdin and stdout, which is why <code>tostring</code> can locally reassign <code>stdout</code> to be going to a string, but that doesn’t mess up other threads printing to <i>their</i> <code>stdout</code> at the same time.</p
><p
>This library provides a light wrapper around MzScheme parameters, allowing dynamic variables to be declared and used in Arc.</p
><p
>The <code>declare-dynamic</code> macro declares a dynamic variable, with an optional initial value:</p
><blockquote
><pre
>
  arc&#62; (declare-dynamic a 3)
  nil
  arc&#62; (def foo () a)
  #&#60;procedure: foo&#62;
  arc&#62; (foo)
  3
</pre
></blockquote
><p
>Much like a macro has to be defined before it can be used, a dynamic variable has to be declared before it’s used:</p
><blockquote
><pre
>
  arc&#62; (def foo () a)
  #&#60;procedure: foo&#62;
  arc&#62; (declare-dynamic a 3)
  nil
  arc&#62; (foo)
  #&#60;primitive:parameter-procedure&#62;
</pre
></blockquote
><p
>Here we see that <code>foo</code> wasn’t able to get the <i>value</i> of the dynamic variable (instead getting the underlying MzScheme implementation of the variable), because <code>foo</code> was defined before <code>a</code> was declared to be a dynamic variable.</p
><p
>The <code>dynamic</code> form causes the value of the dynamic variable to be changed during the execution of the <code>dynamic</code>.  This is not a lexical scope, since the change affects any called function that uses the variable:</p
><blockquote
><pre
>
  arc&#62; (declare-dynamic a 3)
  nil
  arc&#62; (def foo () a)
  #&#60;procedure: foo&#62;
  arc&#62; (dynamic a 5 (foo))
  5
</pre
></blockquote
><p
>Outside the <code>dynamic</code>, the variable still has its original value:</p
><blockquote
><pre
>
  arc&#62; a
  3
</pre
></blockquote
><p
>The value of the variable can be set while inside the <code>dynamic</code>, and that change will be visible to other functions being called while inside the <code>dynamic</code>, but the change won’t affect the value of the dynamic variable outside:</p
><blockquote
><pre
>
 arc&#62; (declare-dynamic a 3)
 nil
 arc&#62; (def foo () (++ a))
 #&#60;procedure: foo&#62;
 arc&#62; (dynamic a 10
        (prn (foo))
        (prn (foo))
        (prn (foo))
        nil)
 11
 12
 13
 nil
 arc&#62; a
 3
</pre
></blockquote
><p
>Being “outside” the <code>dynamic</code> includes not only exiting the <code>dynamic</code> normally or with an exception, but also being outside the <code>dynamic</code> with continuations or threads:</p
><blockquote
><pre
>
 arc&#62; (declare-dynamic a 3)
 nil
 arc&#62; (def foo () (++ a))
 #&#60;procedure: foo&#62;
 arc&#62; (do (thread (repeat 10
                     (prn &#34;thread: &#34; a)
                     (sleep 1)))
          (dynamic a 5
            (repeat 5
              (prn (foo))
              (sleep 2))))
 6
 thread: 3
 thread: 3
 7
 thread: 3
 thread: 3
 8
 thread: 3
 thread: 3
 9
 thread: 3
 thread: 3
 10
 thread: 3
 thread: 3
 nil
</pre
></blockquote
><h2
>Get This Hack</h2
><p
>This hack needs the “mz” and “autocall” patches applied to Arc:</p
><blockquote
><pre
>
 $ wget http://ycombinator.com/arc/arc3.tar
 $ tar xf arc3.tar
 $ cd arc3
 $ curl http://catdancer.github.com/mz1.patch | patch
 $ curl http://catdancer.github.com/autocall0.patch | patch
</pre
></blockquote
><p
>And you’ll need the “autocall” and “dyn” libraries:</p
><blockquote
><pre
>
 $ wget http://catdancer.github.com/autocall0.arc
 $ wget http://catdancer.github.com/dyn0.arc
 $ mzscheme -m -f as.scm
 Use (quit) to quit, (tl) to return here after an interrupt.
 arc&#62; (load &#34;autocall0.arc&#34;)
 nil
 arc&#62; (load &#34;dyn0.arc&#34;)
 nil
</pre
></blockquote
></body
></html
>
